name: ðŸ›¡ï¸ Dependabot Security PR â†’ Auto Create/Update Issue

on:
  pull_request:
    types: [opened, synchronize, closed, reopened]

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  process-dependabot-security-pr:
    if: github.event.pull_request.user.login == 'dependabot[bot]' && contains(github.event.pull_request.title, 'Bumps')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Extract info & Create/Update Issue
        uses: actions/github-script@v7
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        with:
          script: |
            const { context, github } = require('@actions/github');
            const payload = context.payload;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const prBody = process.env.PR_BODY || payload.pull_request.body || '';

            // Parse data
            let severity = 'UNKNOWN';
            let ghsa = 'No GHSA';
            let cve = 'No CVE';
            let cvss = 'N/A';
            let vector = 'N/A';
            let pkg = 'Unknown';
            let eco = 'Unknown';
            let vulnRange = 'Unknown';
            let patched = 'None';
            let summary = 'Dependabot security update detected. Merge PR to fix vulnerability.';

            const severityMatch = prBody.match(/\*\*Severity:\*\*\s*(\w+)/i) || prBody.match(/Severity:\s*(\w+)/i) || prBody.match(/severity:\s*(\w+)/i);
            if (severityMatch) severity = severityMatch[1].toUpperCase();

            const ghsaMatch = prBody.match(/(GHSA[-a-zA-Z0-9]+)/i);
            if (ghsaMatch) ghsa = ghsaMatch[1];
            const cveMatch = prBody.match(/(CVE-\d{4}-\d+)/i);
            if (cveMatch) cve = cveMatch[1];

            const pkgMatch = process.env.PR_TITLE.match(/Bumps\s+([^\s]+)/) || prBody.match(/Bumps\s+([^\s]+)\s+from/);
            if (pkgMatch) pkg = pkgMatch[1];

            const depBlockMatch = prBody.match(/updated-dependencies:([\s\S]*?)(?=\n---|$)/);
            if (depBlockMatch) {
              const block = depBlockMatch[1];
              const nameMatch = block.match(/dependency-name:\s*["']?([^"'\n]+)["']?/);
              if (nameMatch && pkg === 'Unknown') pkg = nameMatch[1].trim();
            }

            const rangeMatch = prBody.match(/(?:Affected|vulnerable)\s+versions?[:\s]*([^\n]+)/i);
            if (rangeMatch) vulnRange = rangeMatch[1].trim();
            const patchedMatch = prBody.match(/(?:Patched|fixed)\s+in?[:\s]*([^\n]+)/i);
            if (patchedMatch) patched = patchedMatch[1].trim();

            // Labels severity sesuai repo kamu
            let issueLabels = ['Security', 'Auto Create Issues', 'dependencies'];
            let severityLabel = 'Low'; // fallback
            severity = 'LOW'; // default checkbox
            if (severity === 'CRITICAL') {
              severityLabel = 'Critical';
              severity = 'CRITICAL';
            } else if (severity === 'HIGH') {
              severityLabel = 'High';
              severity = 'HIGH';
            } else if (severity === 'MODERATE') {
              severityLabel = 'Moderate';
              severity = 'MODERATE';
            }
            issueLabels.push(severityLabel);

            // Title issue
            const title = `Security: ${severity} - ${pkg} (${ghsa} / ${cve})`;

            // Cari existing issue
            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'all', labels: 'Auto Create Issues', per_page: 100 }
            );
            const existing = issues.find(i => i.title === title);

            // Body issue dengan indentasi aman (4 spasi)
            const body = `
                ## ðŸ›¡ï¸ Security Vulnerability (from Dependabot PR #${process.env.PR_NUMBER})

                ### Description
                ${summary}

                ### Severity Check
                - ${severity === 'LOW' ? 'â˜‘' : 'â˜'} Low
                - ${severity === 'MODERATE' ? 'â˜‘' : 'â˜'} Moderate
                - ${severity === 'HIGH' ? 'â˜‘' : 'â˜'} High
                - ${severity === 'CRITICAL' ? 'â˜‘' : 'â˜'} Critical

                ### Severity Score
                ${cvss} / 10

                ### CVSS Vector
                ${vector}

                ### Affected
                - **Package:** ${pkg}
                - **Ecosystem:** ${eco}
                - **Vulnerable versions:** ${vulnRange}
                - **Patched version:** ${patched}

                ### References
                - Advisory: https://github.com/advisories/${ghsa}
                - PR: ${process.env.PR_URL}
                - Dependabot Alert: https://github.com/${owner}/${repo}/security/dependabot

                ---
                _Auto-generated from Dependabot security PR. Fix by merging PR #${process.env.PR_NUMBER}._
            `.trim();

            if (payload.action === 'opened' || payload.action === 'synchronize' || payload.action === 'reopened') {
              if (!existing) {
                await github.rest.issues.create({
                  owner, repo,
                  title,
                  body,
                  labels: issueLabels,
                  assignees: ['TheKingTermux']
                });
                console.log(`Created issue: ${title} with labels ${issueLabels.join(', ')}`);
              } else {
                await github.rest.issues.update({
                  owner, repo,
                  issue_number: existing.number,
                  body,
                  state: 'open'
                });
                const currentLabels = existing.labels.map(l => l.name);
                const missingLabels = issueLabels.filter(l => !currentLabels.includes(l));
                if (missingLabels.length > 0) {
                  await github.rest.issues.addLabels({
                    owner, repo,
                    issue_number: existing.number,
                    labels: missingLabels
                  });
                }
                console.log(`Updated issue: ${title}`);
              }
            }

            if (payload.action === 'closed' && existing) {
              const labels = existing.labels.map(l => l.name);
              if (!labels.includes('do-not-autoclose')) {
                await github.rest.issues.update({
                  owner, repo,
                  issue_number: existing.number,
                  state: 'closed',
                  state_reason: 'completed'
                });
                console.log(`Closed issue: ${title}`);
              }
            }
